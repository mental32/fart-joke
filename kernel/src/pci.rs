//! PCI Local Bus and PCI-E (PCI Express) utilities.

use core::{cell::RefCell, ops::Range};

use cpuio::UnsafePort;
use pci_types::{ConfigRegionAccess, PciAddress, PciHeader};

// Autogenerated from build.rs
include!(concat!(env!("OUT_DIR"), "/pci_ids.rs"));

const BUS: u8 = 255;
const DEV: u8 = 32;
const FUN: u8 = 8;

// Two 32-bit I/O locations are used, the first location (0xCF8) is named CONFIG_ADDRESS,
// and the second (0xCFC) is called CONFIG_DATA.
//
// CONFIG_ADDRESS specifies the configuration address that is required to be accesses,
// while accesses to CONFIG_DATA will actually generate the configuration access and will
// transfer the data to or from the CONFIG_DATA register.
const CONFIG_ADDR: u16 = 0xCF8;
const CONFIG_DATA: u16 = 0xCFC;

// -- PciDevice

pub struct PciDevice(pub(crate) PciAddress);

impl PciDevice {
    #[inline]
    pub fn id(
        &self,
        access: &impl ConfigRegionAccess,
    ) -> (pci_types::VendorId, pci_types::DeviceId) {
        PciHeader::new(self.0).id(access)
    }

    #[inline]
    pub fn bars(&self, access: &impl ConfigRegionAccess) -> [u32; 6] {
        let mut bars = [0u32; 6];

        unsafe {
            for (idx, offset) in (0x10u16..=0x24).step_by(0x04).enumerate() {
                bars[idx] = access.read(self.0, offset);
            }
        };

        bars
    }

    #[inline]
    pub fn supported_fns(&self, access: &impl ConfigRegionAccess) -> u8 {
        let bus = self.0.bus();
        let dev = self.0.device();

        let check_remaining_functions = || {
            // It is a multi-function device, so check remaining functions.
            use bit_field::BitField;

            let mut supported = 1u8;

            for fun in 0..8usize {
                let addr = PciAddress::new(0, bus, dev, fun as u8);
                let header = PciHeader::new(addr);

                supported.set_bit(fun, header.id(access).1 != 0xFFFF);
            }

            supported
        };

        PciHeader::new(self.0)
            .has_multiple_functions(access)
            .then(check_remaining_functions)
            .unwrap_or(1u8)
    }
}

// -- PciPorts

#[derive(Debug)]
pub struct PciPorts {
    addr: RefCell<UnsafePort<u32>>,
    data: RefCell<UnsafePort<u32>>,
}

impl PciPorts {
    #[inline]
    pub const unsafe fn new() -> Self {
        let addr = RefCell::new(UnsafePort::new(CONFIG_ADDR));
        let data = RefCell::new(UnsafePort::new(CONFIG_DATA));

        Self { addr, data }
    }
}

impl pci_types::ConfigRegionAccess for PciPorts {
    fn function_exists(&self, address: pci_types::PciAddress) -> bool {
        todo!()
    }

    unsafe fn read(&self, address: pci_types::PciAddress, offset: u16) -> u32 {
        let bus = address.bus() as u32;
        let device = address.device() as u32;
        let func = address.function() as u32;
        let offset = offset as u32;

        // construct address param
        let address =
            ((bus << 16) | (device << 11) | (func << 8) | (offset & 0xfc) | 0x80000000) as u32;

        // write address
        self.addr.borrow_mut().write(address);

        // read data
        self.data.borrow_mut().read()
    }

    unsafe fn write(&self, address: pci_types::PciAddress, offset: u16, value: u32) {
        let bus = address.bus() as u32;
        let device = address.device() as u32;
        let func = address.function() as u32;
        let offset = offset as u32;

        // construct address param
        let address =
            ((bus << 16) | (device << 11) | (func << 8) | (offset & 0xfc) | 0x80000000) as u32;

        // write address
        self.addr.borrow_mut().write(address);

        // write data
        self.data.borrow_mut().write(value)
    }
}

// -- PciEnumerate

pub unsafe fn enumerate<'a>(access: &'a PciPorts) -> impl Iterator<Item = PciDevice> + 'a {
    PciEnumerate::new(access)
}

#[derive(Debug)]
struct PciEnumerate<'a> {
    access: &'a PciPorts,
    bus: u8,
    device: u8,
}

impl<'a> PciEnumerate<'a> {
    unsafe fn new(access: &'a PciPorts) -> Self {
        Self {
            bus: 0,
            device: 0,
            access,
        }
    }
}

impl<'a> Iterator for PciEnumerate<'a> {
    type Item = PciDevice;

    fn next(&mut self) -> Option<Self::Item> {
        if self.bus < BUS {
            log::trace!(
                "Starting PCI enumerate at bus={:?} dev={:?}",
                self.bus,
                self.device
            );

            for bus in self.bus..BUS {
                for dev in self.device..DEV {
                    let addr = PciAddress::new(0, bus, dev, 0);
                    let header = PciHeader::new(addr);

                    let (device_id, vendor_id) = header.id(self.access);

                    if vendor_id == 0xFFFF {
                        // Device does not exist.
                        continue;
                    }

                    self.device = dev.saturating_add(1);

                    if self.device == DEV {
                        self.bus = self.bus.saturating_add(1);
                        self.device = 0;
                    }

                    log::trace!(
                        "Parking PCI enumerate at bus={:?} dev={:?}",
                        self.bus,
                        self.device
                    );

                    return Some(PciDevice(addr));
                }
            }
        }

        self.bus = BUS;
        self.device = DEV;

        log::trace!(
            "Bailing PCI enumerate bus={:?} dev={:?}",
            self.bus,
            self.device
        );

        None
    }
}
